{"version":3,"file":"esri-leaflet-gp.js","sources":["../src/Tasks/Geoprocessing.js","../src/Services/Geoprocessing.js"],"sourcesContent":["/*\nto do:\nsetParam([])\n*/\n\nimport L from 'leaflet';\nimport { Task as BaseTask, Util } from 'esri-leaflet';\n\nexport const Task = BaseTask.extend({\n\n  includes: L.Evented.prototype,\n\n  // setters: {}, we don't use these because we don't know the ParamName OR value of custom GP services\n  params: {},\n  resultParams: {},\n\n  initialize: function (options) {\n    // don't replace parent initialize\n    BaseTask.prototype.initialize.call(this, options);\n\n    // if no constuctor options are supplied try and determine if its sync or async and set path via metadata\n    if (!this.options.path && typeof this.options.async === 'undefined') {\n      // assume initially that the service is synchronous\n      this.options.async = false;\n      this.options.path = 'execute';\n\n      // the parameters below seem wonky to me, but work for both CORS and JSONP requests\n      this._service.metadata(function (error, results) {\n        if (!error) {\n          if (results.executionType === 'esriExecutionTypeSynchronous') {\n            this.options.async = false;\n            this.options.path = 'execute';\n          } else {\n            this.options.async = true;\n            this.options.path = 'submitJob';\n          }\n          this.fire('initialized');\n        } else {\n          // abort\n\n        }\n      }, this);\n    } else {\n      // if async is set, but not path, default to submit job\n      if (this.options.async) {\n        this.options.path = this.options.path ? this.options.path : 'submitJob';\n      }\n      if (!this.options.async) {\n        this.options.path = this.options.path ? this.options.path : 'execute';\n      }\n    }\n  },\n\n  // doc for various GPInput types can be found here\n  // http://resources.arcgis.com/en/help/arcgis-rest-api/index.html#/GP_Result/02r3000000q7000000/\n  setParam: function (paramName, paramValue) {\n    if (typeof paramValue === 'boolean' || typeof paramValue !== 'object') {\n      // pass through booleans, numbers, strings\n      this.params[paramName] = paramValue;\n    } else if (typeof paramValue === 'object' && paramValue.units) {\n      // pass through GPLinearUnit params unmolested also\n      this.params[paramName] = paramValue;\n    } else if (paramName === 'geometry') {\n      // convert raw geojson geometries to esri geometries\n      this.params[paramName] = this._setGeometry(paramValue);\n    } else {\n      // otherwise assume its latlng, marker, bounds or geojson and package up an array of esri features\n      const geometryType = this._setGeometryType(paramValue);\n      const esriFeatures = {\n        features: []\n      };\n\n      if (geometryType) {\n        esriFeatures.geometryType = geometryType;\n      }\n      if (paramValue.type === 'FeatureCollection' && paramValue.features[0].type === 'Feature') {\n        for (let i = 0; i < paramValue.features.length; i++) {\n          if (paramValue.features[i].type === 'Feature') {\n            // pass through feature attributes and geometries\n            esriFeatures.features.push(Util.geojsonToArcGIS(paramValue.features[i]));\n          } else {\n            // otherwise assume the array only contains geometries\n            esriFeatures.features.push({ geometry: Util.geojsonToArcGIS(paramValue.features[i].geometry) });\n          }\n        }\n      } else {\n        esriFeatures.features.push({ geometry: this._setGeometry(paramValue) });\n      }\n      this.params[paramName] = esriFeatures;\n    }\n  },\n\n  // give developer opportunity to point out where the output is going to be available\n  setOutputParam: function (paramName) {\n    this.params.outputParam = paramName;\n  },\n\n  /* async elevation services need resultParams in order to return Zs (unnecessarily confusing) */\n  gpAsyncResultParam: function (paramName, paramValue) {\n    this.resultParams[paramName] = paramValue;\n  },\n\n  // we currently expect a single geometry or feature (ported from: Tasks.Query._setGeometry)\n  _setGeometry: function (geometry) {\n    // convert bounds to extent and finish\n    if (geometry instanceof L.LatLngBounds) {\n      return L.esri.Util.boundsToExtent(geometry);\n    }\n\n    // convert L.Marker > L.LatLng\n    if (geometry.getLatLng) {\n      geometry = geometry.getLatLng();\n    }\n\n    // convert L.LatLng to a geojson point and continue;\n    if (geometry instanceof L.LatLng) {\n      geometry = {\n        type: 'Point',\n        coordinates: [geometry.lng, geometry.lat]\n      };\n    }\n\n    // handle L.GeoJSON, pull out the first geometry\n    if (geometry instanceof L.GeoJSON) {\n      // reassign geometry to the GeoJSON value  (we assume one feature is present)\n      geometry = geometry.getLayers()[0].feature.geometry;\n      // processedInput.geometryType = Util.geojsonTypeToArcGIS(geometry.type);\n      return Util.geojsonToArcGIS(geometry);\n    }\n\n    // Handle L.Polyline and L.Polygon\n    if (geometry.toGeoJSON) {\n      geometry = geometry.toGeoJSON();\n    }\n\n    // handle GeoJSON feature by pulling out the geometry\n    if (geometry.type === 'Feature') {\n      // get the geometry of the geojson feature\n      geometry = geometry.geometry;\n    }\n\n    // confirm that our GeoJSON is a point, line or polygon\n    if (geometry.type === 'Point' || geometry.type === 'LineString' || geometry.type === 'Polygon') {\n      return Util.geojsonToArcGIS(geometry);\n      // processedInput.geometryType = Util.geojsonTypeToArcGIS(geometry.type);\n    } else {\n      Util.warn('invalid geometry passed as GP input. Should be an L.LatLng, L.LatLngBounds, L.Marker or GeoJSON Point Line or Polygon object');\n    }\n  },\n\n  _setGeometryType: function (geometry) {\n    if (geometry instanceof L.LatLngBounds) {\n      return 'esriGeometryEnvelope';\n    }\n\n    // convert L.Marker > L.LatLng\n    if (geometry.getLatLng || geometry instanceof L.LatLng) {\n      return 'esriGeometryPoint';\n    }\n\n    // handle L.GeoJSON, pull out the first geometry\n    if (geometry instanceof L.GeoJSON) {\n      geometry = geometry.getLayers()[0].feature.geometry;\n      return Util.geojsonTypeToArcGIS(geometry.type);\n    }\n\n    // Handle L.Polyline and L.Polygon\n    if (geometry.toGeoJSON) {\n      geometry = geometry.toGeoJSON();\n    }\n\n    // handle GeoJSON feature by pulling out the geometry\n    if (geometry.type === 'Feature') {\n      // get the geometry of the geojson feature\n      geometry = geometry.geometry;\n    }\n\n    // confirm that our GeoJSON is a point, line or polygon\n    if (geometry.type === 'Point' || geometry.type === 'LineString' || geometry.type === 'Polygon') {\n      return Util.geojsonTypeToArcGIS(geometry.type);\n    } else if (geometry.type === 'FeatureCollection') {\n      return Util.geojsonTypeToArcGIS(geometry.features[0].type);\n    } else {\n      return null;\n    }\n  },\n\n  run: function (callback, context) {\n    this._done = false;\n\n    if (this.options.async === true) {\n      /* eslint-disable */\n      this._service.request(this.options.path, this.params, function (error, response) {\n        this._currentJobId = response.jobId;\n        this.checkJob(this._currentJobId, callback, context);\n      }, this);\n      /* eslint-enable */\n    } else {\n      return this._service.request(this.options.path, this.params, function (error, response) {\n        if (!error) {\n          if (response.results) {\n            callback.call(context, error, (response && this._processGPOutput(response)), response);\n          } else if (response.histograms) {\n            callback.call(context, error, response, response);\n          } else if (response.routes) {\n            callback.call(context, error, (response && this._processNetworkAnalystOutput(response)), response);\n          }\n        } else {\n          callback.call(context, error, null, null);\n        }\n      }, this);\n    }\n  },\n\n  getResult: function (jobId, output, callback, context) {\n    this._service.request(\n      'jobs/' + jobId + '/results/' + output,\n      this.resultParams,\n      function processJobResult (error, response) {\n        let result = null;\n        const out = (response && this._processAsyncOutput(response));\n\n        if (output in out) {\n          result = out[output];\n        }\n\n        callback.call(\n          context,\n          error,\n          result,\n          response\n        );\n      }, this);\n  },\n\n  checkJob: function (jobId, callback, context) {\n    const pollJob = function () {\n      /* eslint-disable */\n      this._service.request('jobs/' + jobId, {}, function polledJob (error, response) {\n        if (response.jobStatus === 'esriJobSucceeded') {\n          if (!this._done) {\n            this._done = true;\n            // to do:\n            // refactor to make an array of async requests for output\n            this._service.request('jobs/' + jobId + '/results/' + this.params.outputParam, this.resultParams, function processJobResult (error, response) {\n              callback.call(context, error, (response && this._processAsyncOutput(response)), response);\n            }, this);\n          }\n          window.clearInterval(counter);\n        } else if (response.jobStatus === 'esriJobFailed') {\n          callback.call(context, 'Job Failed', null);\n          window.clearInterval(counter);\n        }\n      }, this);\n      /* eslint-enable */\n    }.bind(this);\n\n    const counter = window.setInterval(pollJob, this._service.options.asyncInterval * 1000);\n  },\n\n  _processGPOutput: function (response) {\n    const processedResponse = {};\n\n    const results = response.results;\n    // grab syncronous results\n    if (this.options.async === false) {\n      // loop through results and pass back, parsing esri json\n      for (let i = 0; i < results.length; i++) {\n        if (results[i].dataType === 'GPFeatureRecordSetLayer') {\n          const featureCollection = Util.responseToFeatureCollection(results[i].value);\n          processedResponse[results[i].paramName] = featureCollection;\n        } else {\n          processedResponse[results[i].paramName] = results[i].value;\n        }\n      }\n    } else { // grab async results slightly differently\n      processedResponse.jobId = this._currentJobId;\n      // var responseValue = response.value;\n    }\n\n    // if output is a raster layer, we also need to stub out a MapService url using jobid\n    if (this.options.async === true && response.dataType === 'GPRasterDataLayer') {\n      const baseURL = this.options.url;\n      const n = baseURL.indexOf('GPServer');\n      const serviceURL = baseURL.slice(0, n) + 'MapServer/';\n      processedResponse.outputMapService = serviceURL + 'jobs/' + this._currentJobId;\n    }\n\n    return processedResponse;\n  },\n\n  _processNetworkAnalystOutput: function (response) {\n    const processedResponse = {};\n\n    if (response.routes.features.length > 0) {\n      const featureCollection = Util.responseToFeatureCollection(response.routes);\n      processedResponse.routes = featureCollection;\n    }\n\n    return processedResponse;\n  },\n\n  _processAsyncOutput: function (response) {\n    const processedResponse = {};\n    processedResponse.jobId = this._currentJobId;\n\n    // if output is a raster layer, we also need to stub out a MapService url using jobid\n    if (this.options.async === true && response.dataType === 'GPRasterDataLayer') {\n      const baseURL = this.options.url;\n      const n = baseURL.indexOf('GPServer');\n      const serviceURL = baseURL.slice(0, n) + 'MapServer/';\n      processedResponse.outputMapService = serviceURL + 'jobs/' + this._currentJobId;\n    }\n\n    // if output is GPFeatureRecordSetLayer, convert to GeoJSON\n    if (response.dataType === 'GPFeatureRecordSetLayer') {\n      const featureCollection = Util.responseToFeatureCollection(response.value);\n      processedResponse[response.paramName] = featureCollection;\n    } else {\n      processedResponse[response.paramName] = response.value;\n    }\n\n    return processedResponse;\n  }\n\n});\n\nexport function task (options) {\n  return new Task(options);\n}\n\nexport default task;\n","import { Service as BaseService } from 'esri-leaflet';\nimport { Task } from '../Tasks/Geoprocessing';\n\nexport const Service = BaseService.extend({\n  options: {\n    asyncInterval: 1\n  },\n\n  createTask: function () {\n    return new Task(this, this.options);\n  }\n\n});\n\nexport function service (options) {\n  return new Service(options);\n}\n\nexport default service;\n"],"names":["Task","BaseTask","extend","includes","L","Evented","prototype","params","resultParams","initialize","options","call","this","path","async","_service","metadata","error","results","executionType","fire","setParam","paramName","paramValue","units","_setGeometry","geometryType","_setGeometryType","esriFeatures","features","type","let","i","length","push","Util","geojsonToArcGIS","geometry","setOutputParam","outputParam","gpAsyncResultParam","LatLngBounds","esri","boundsToExtent","getLatLng","LatLng","coordinates","lng","lat","GeoJSON","getLayers","feature","toGeoJSON","warn","geojsonTypeToArcGIS","run","callback","context","_done","request","response","_processGPOutput","histograms","routes","_processNetworkAnalystOutput","_currentJobId","jobId","checkJob","getResult","output","result","out","_processAsyncOutput","pollJob","jobStatus","window","clearInterval","counter","bind","setInterval","asyncInterval","processedResponse","featureCollection","dataType","responseToFeatureCollection","value","baseURL","url","n","indexOf","serviceURL","slice","outputMapService","Service","BaseService","createTask"],"mappings":"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"}